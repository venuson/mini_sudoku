{"version":3,"sources":["file:///Users/ruiwei/Documents/cocos/SudokuWechatGame/assets/scripts/vendor/SudokuCore.ts"],"names":["SudokuCore","COLS","DIGITS","SQUARES","UNITS","SQUARE_UNITS_MAP","SQUARE_PEERS_MAP","MIN_GIVENS","NR_SQUARES","BLANK_CHAR","BLANK_BOARD","initialize","console","log","_cross","ROWS","_get_all_units","_get_square_units_map","_get_square_peers_map","generate","difficulty","unique","Error","difficultyLevel","DIFFICULTY","easy","_force_range","isUnique","undefined","candidates","_get_candidates_map","error","shuffled_squares","_shuffle","square","candidatesForSquare","length","rand_candidate_idx","_rand_range","rand_candidate","assignmentResult","_assign","single_candidates","sq","push","_strip_dups","board","givens_idxs","i","nr_givens","shuffled_givens_idxs","boardChars","split","target_index","join","solve","reverse","report","validate_board","char","_in","result","_search","solution","get_candidates","candidates_map","rows","cur_row","candidate_map","squares_values_map","_get_square_vals_map","val","max_nr_candidates","isSolved","nr_candidates","min_nr_candidates","min_candidates_square","min_candidates","candidatesToTry","candidates_copy","JSON","parse","stringify","candidates_next","other_vals","replace","other_val","eliminateResult","_eliminate","target_val","peers","peer","units","unit","val_places","unit_square","target_square","assignResult","squares_vals_map","squares","square_unit_map","cur_square","cur_square_units","cur_unit","includes","units_map","square_peers_map","cur_square_peers","peer_set","Set","cur_unit_square","add","Array","from","cols","r","c","row_squares","col_squares","rs","cs","board_string_to_grid","board_string","board_grid_to_string","board_grid","warn","print_board","V_PADDING","H_PADDING","V_BOX_PADDING","H_BOX_PADDING","display_string","a","b","charA","charB","v","seq","indexOf","first_true","item","shuffled","j","Math","floor","random","max","min","nr","num"],"mappings":"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","sourcesContent":["// --- START OF FILE sudoku_core.ts ---\n\nexport default class SudokuCore {\n  static readonly DIGITS: string = \"123456789\";\n  static readonly ROWS: string = \"ABCDEFGHI\";         // Row labels\n  readonly COLS: string = SudokuCore.DIGITS;       // Column labels\n  SQUARES: string[] | null = null;             // Square IDs [\"A1\", \"A2\", ..., \"I9\"]\n\n  UNITS: string[][] | null = null;               // All units (row, column, or box), each unit is string[]\n  SQUARE_UNITS_MAP: Record<string, string[][]> | null = null;    // Squares -> units map\n  SQUARE_PEERS_MAP: Record<string, string[]> | null = null;    // Squares -> peers map\n\n  readonly MIN_GIVENS: number = 17;            // Minimum number of givens\n  readonly NR_SQUARES: number = 81;            // Number of squares\n\n  // Define difficulties by how many squares are given to the player in a new\n  // puzzle.\n  static readonly DIFFICULTY: Record<string, number> = {\n    \"easy\":         62,\n    \"medium\":       53,\n    \"hard\":         44,\n    \"very-hard\":    35,\n    \"insane\":       26,\n    \"inhuman\":      17,\n  };\n  readonly BLANK_CHAR: string = '.';\n  readonly BLANK_BOARD: string = \"....................................................\"+\n    \".............................\";\n\n  // It's recommended to call initialize() immediately after instantiation,\n  // or call it from a constructor if automatic initialization is desired.\n  public initialize(): void {\n    console.log('sudoku initialize');\n    this.SQUARES             = this._cross(SudokuCore.ROWS, this.COLS);\n    this.UNITS               = this._get_all_units(SudokuCore.ROWS, this.COLS);\n    // Non-null assertions (!) are used here assuming initialize is called correctly.\n    this.SQUARE_UNITS_MAP    = this._get_square_units_map(this.SQUARES!, this.UNITS!);\n    this.SQUARE_PEERS_MAP    = this._get_square_peers_map(this.SQUARES!, this.SQUARE_UNITS_MAP!);\n  }\n\n  public generate(difficulty?: string | number, unique?: boolean): string {\n    // Ensure SQUARES is initialized\n    if (!this.SQUARES) {\n        throw new Error(\"SudokuCore not initialized. Call initialize() first.\");\n    }\n\n    let difficultyLevel: number;\n    if (typeof difficulty === \"string\") {\n      difficultyLevel = SudokuCore.DIFFICULTY[difficulty] || SudokuCore.DIFFICULTY.easy;\n    } else if (typeof difficulty === \"number\") {\n      difficultyLevel = difficulty;\n    } else {\n      difficultyLevel = SudokuCore.DIFFICULTY.easy;\n    }\n\n    // Force difficulty between 17 and 81 inclusive\n    difficultyLevel = this._force_range(difficultyLevel, this.NR_SQUARES, // max is exclusive in _force_range, but logic implies inclusive here? Adjusting max.\n      this.MIN_GIVENS);\n    // Let's adjust _force_range or the call to match the comment \"between 17 and 81 inclusive\"\n    // Assuming _force_range's max is exclusive, we need NR_SQUARES + 1\n    difficultyLevel = this._force_range(difficultyLevel, this.NR_SQUARES + 1, this.MIN_GIVENS);\n\n\n    // Default unique to true\n    const isUnique = unique === undefined ? true : unique; // Explicit boolean check\n\n    // Get a set of squares and all possible candidates for each square\n    // Use BLANK_BOARD constant\n    let candidates = this._get_candidates_map(this.BLANK_BOARD);\n\n    // Check if candidates generation failed (shouldn't for blank board, but good practice)\n    if (!candidates) {\n        console.error(\"Failed to get initial candidates for a blank board.\");\n        // Retry generation\n        return this.generate(difficulty, unique);\n    }\n\n\n    // For each item in a shuffled list of squares\n    const shuffled_squares = this._shuffle(this.SQUARES); // SQUARES is guaranteed non-null here\n    for (const square of shuffled_squares) {\n\n      // If an assignment of a random choice causes a contradiction, give up and try again\n      const candidatesForSquare = candidates[square];\n      if (!candidatesForSquare || candidatesForSquare.length === 0) {\n          // Should not happen in this algorithm flow unless board became invalid\n          break; // Break loop and retry generation\n      }\n      const rand_candidate_idx = this._rand_range(candidatesForSquare.length);\n      const rand_candidate = candidatesForSquare[rand_candidate_idx];\n\n      // _assign returns false on contradiction\n      const assignmentResult = this._assign(candidates, square, rand_candidate);\n      if (!assignmentResult) {\n        // Contradiction found, break and retry generation\n        break;\n      }\n      // Update candidates map with the result (as _assign modifies it)\n      candidates = assignmentResult;\n\n\n      // Make a list of all single candidates (solved squares)\n      const single_candidates: string[] = [];\n      for (const sq of this.SQUARES) { // Use SQUARES which is non-null\n        if (candidates[sq].length === 1) {\n          single_candidates.push(candidates[sq]);\n        }\n      }\n\n      // If we have at least difficultyLevel filled squares, and the unique candidate count is\n      // at least 8 (ensures some variety), return the puzzle!\n      if (single_candidates.length >= difficultyLevel &&\n          this._strip_dups(single_candidates).length >= 8) {\n\n        let board = \"\";\n        const givens_idxs: number[] = [];\n        for (let i = 0; i < this.SQUARES.length; i++) {\n          const sq = this.SQUARES[i];\n          if (candidates[sq].length === 1) {\n            board += candidates[sq];\n            givens_idxs.push(i);\n          } else {\n            board += this.BLANK_CHAR;\n          }\n        }\n\n        // If we have more than `difficultyLevel` givens, remove some random\n        // givens until we're down to exactly `difficultyLevel`\n        let nr_givens = givens_idxs.length;\n        if (nr_givens > difficultyLevel) {\n          let shuffled_givens_idxs = this._shuffle(givens_idxs);\n          const boardChars = board.split(''); // Modifiable array\n          for (let i = 0; i < nr_givens - difficultyLevel; ++i) {\n            const target_index = shuffled_givens_idxs[i]; // Index is already a number\n            boardChars[target_index] = this.BLANK_CHAR;\n          }\n          board = boardChars.join('');\n        }\n\n        // Double check board is solvable\n        // TODO: Make a standalone board checker. Solve is expensive.\n        if (this.solve(board)) {\n          return board;\n        }\n        // If not solvable (should be rare here), loop continues / eventually retries\n      }\n    }\n\n    // Give up and try a new puzzle\n    return this.generate(difficulty, unique);\n  }\n\n  // Solve\n  // -------------------------------------------------------------------------\n  public solve(board: string, reverse: boolean = false): string | false {\n    // Ensure SQUARES is initialized\n    if (!this.SQUARES || !this.SQUARE_PEERS_MAP || !this.SQUARE_UNITS_MAP) {\n        throw new Error(\"SudokuCore not initialized. Call initialize() first.\");\n    }\n\n    const report = this.validate_board(board);\n    if (report !== true) {\n      throw new Error(report); // Throw Error object\n    }\n\n    // Check number of givens is at least MIN_GIVENS\n    let nr_givens = 0;\n    for (const char of board) {\n      if (char !== this.BLANK_CHAR && this._in(char, SudokuCore.DIGITS)) {\n        ++nr_givens;\n      }\n    }\n    if (nr_givens < this.MIN_GIVENS) {\n      throw new Error(\"Too few givens. Minimum givens is \" + this.MIN_GIVENS);\n    }\n\n    const candidates = this._get_candidates_map(board);\n    // Check if initial propagation led to contradiction\n    if (!candidates) {\n        return false;\n    }\n\n    const result = this._search(candidates, reverse);\n    console.log(\"Search result:\", result); // Keep original log\n\n    if (result) {\n      let solution = \"\";\n      // Ensure SQUARES is available and iterate in order\n      for (const square of this.SQUARES) {\n        solution += result[square];\n      }\n      return solution;\n    }\n    return false;\n  }\n\n  public get_candidates(board: string): string[][] | null {\n     // Ensure SQUARES is initialized\n    if (!this.SQUARES) {\n        throw new Error(\"SudokuCore not initialized. Call initialize() first.\");\n    }\n\n    // Assure a valid board\n    const report = this.validate_board(board);\n    if (report !== true) {\n      throw new Error(report);\n    }\n\n    // Get a candidates map\n    const candidates_map = this._get_candidates_map(board);\n\n    // If there's an error (contradiction), return null\n    if (!candidates_map) {\n      return null;\n    }\n\n    // Transform candidates map into grid\n    const rows: string[][] = [];\n    let cur_row: string[] = [];\n    let i = 0;\n    // Iterate in the correct square order\n    for (const square of this.SQUARES) {\n      const candidates = candidates_map[square];\n      cur_row.push(candidates);\n      if (i % 9 === 8) {\n        rows.push(cur_row);\n        cur_row = [];\n      }\n      ++i;\n    }\n    return rows;\n  }\n\n  private _get_candidates_map(board: string): Record<string, string> | false {\n    // Ensure SQUARES is initialized\n    if (!this.SQUARES) {\n        // This is a private method, initialization should be guaranteed by public callers\n        // but adding a check for robustness or if called internally before init.\n        console.error(\"_get_candidates_map called before initialization.\");\n        return false;\n    }\n\n    // Assure a valid board\n    const report = this.validate_board(board);\n    if (report !== true) {\n      // Throwing error might be better, but returning false matches original logic flow\n      console.error(\"Invalid board passed to _get_candidates_map:\", report);\n      return false;\n      // throw new Error(report); // Alternative\n    }\n\n    const candidate_map: Record<string, string> = {};\n    const squares_values_map = this._get_square_vals_map(board);\n\n    // Start by assigning every digit as a candidate to every square\n    for (const square of this.SQUARES) {\n      candidate_map[square] = SudokuCore.DIGITS;\n    }\n\n    // For each non-blank square, assign its value in the candidate map and\n    // propagate.\n    for (const square in squares_values_map) {\n        // No need for hasOwnProperty check if _get_square_vals_map creates a clean object\n        const val = squares_values_map[square];\n\n        if (this._in(val, SudokuCore.DIGITS)) {\n            // Pass a copy? No, original modifies in place.\n            // _assign returns false if contradiction occurs\n            const assignmentResult = this._assign(candidate_map, square, val);\n\n            // Fail if we can't assign val to square\n            if (!assignmentResult) {\n            return false;\n            }\n            // No need to reassign candidate_map = assignmentResult as it's modified in place\n        }\n    }\n\n    return candidate_map;\n  }\n\n  private _search(candidates: Record<string, string> | false, reverse: boolean = false): Record<string, string> | false {\n     // Ensure SQUARES is initialized\n    if (!this.SQUARES) {\n        console.error(\"_search called before initialization.\");\n        return false;\n    }\n\n    // Return if error in previous iteration\n    if (!candidates) {\n      return false;\n    }\n\n    // If only one candidate for every square, we've a solved puzzle!\n    // Return the candidates map.\n    let max_nr_candidates = 0;\n    // let max_candidates_square: string | null = null; // Not actually used\n    let isSolved = true;\n    for (const square of this.SQUARES) {\n      const nr_candidates = candidates[square].length;\n      if (nr_candidates > max_nr_candidates) {\n        max_nr_candidates = nr_candidates;\n        // max_candidates_square = square; // Not used\n      }\n      if (nr_candidates !== 1) {\n          isSolved = false;\n          // Optimization: can break early if only checking if solved\n          // break; // Keep iterating if we need the min candidates square later\n      }\n    }\n\n    if (isSolved) {\n      console.log(\"Solved!\");\n      return candidates;\n    }\n\n    // Choose the blank square with the fewest possibilities > 1\n    let min_nr_candidates = 10; // More than max possible (9)\n    let min_candidates_square: string | null = null;\n    for (const square of this.SQUARES) {\n      const nr_candidates = candidates[square].length;\n\n      if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\n        min_nr_candidates = nr_candidates;\n        min_candidates_square = square;\n      }\n    }\n\n    // If no square found with > 1 candidates (contradicts isSolved check, but safety)\n    // Or if somehow min_candidates_square remained null\n     if (min_candidates_square === null) {\n        // This case implies the board is either solved or invalid (e.g., a square has 0 candidates)\n        // If it was solved, we would have returned earlier.\n        // If invalid, the propagation should have returned false earlier.\n        // This path indicates a potential logic issue or an already invalid state.\n        return false;\n     }\n\n\n    // Recursively search through each of the candidates of the square\n    // starting with the one with fewest candidates.\n\n    const min_candidates = candidates[min_candidates_square]; // Safe due to check above\n\n    const candidatesToTry = reverse ? min_candidates.split('').reverse() : min_candidates.split('');\n\n    for (const val of candidatesToTry) {\n        // Need a deep copy for backtracking\n        // JSON parse/stringify is a common way, but be mindful of limitations (functions, undefined, etc.)\n        // For this data structure (strings in object), it's safe.\n        const candidates_copy = JSON.parse(JSON.stringify(candidates)) as Record<string, string>;\n\n        const assignmentResult = this._assign(candidates_copy, min_candidates_square, val);\n        const candidates_next = this._search(assignmentResult, reverse); // Pass result of _assign\n\n        if (candidates_next) {\n            return candidates_next; // Found solution\n        }\n    }\n\n\n    // If we get through all combinations of the square with the fewest\n    // candidates without finding an answer, there isn't one. Return false.\n    return false;\n  }\n\n  private _assign(candidates: Record<string, string>, square: string, val: string): Record<string, string> | false {\n    // Eliminate all values, *except* for `val`, from `candidates` at\n    // `square` (candidates[square]), and propagate. Return the candidates map\n    // when finished. If a contradiciton is found, return false.\n    // WARNING: This modifies the contents of `candidates` directly.\n\n    // Grab a list of candidates without 'val'\n    const other_vals = candidates[square].replace(val, \"\");\n\n    // Loop through all other values and eliminate them from the candidates\n    // at the current square, and propagate. If at any point we get a\n    // contradiction, return false.\n    for (const other_val of other_vals) {\n      // _eliminate modifies candidates directly and returns false on contradiction\n      const eliminateResult = this._eliminate(candidates, square, other_val);\n      if (!eliminateResult) {\n        //console.log(\"Contradiction found by _eliminate.\");\n        return false;\n      }\n      // No need to reassign candidates = eliminateResult\n    }\n\n    // If all eliminations succeeded, return the modified map\n    return candidates;\n  }\n\n  private _eliminate(candidates: Record<string, string>, square: string, val: string): Record<string, string> | false {\n    // Ensure initialization for map access\n    if (!this.SQUARE_PEERS_MAP || !this.SQUARE_UNITS_MAP) {\n        console.error(\"_eliminate called before initialization.\");\n        return false;\n    }\n    // Eliminate `val` from `candidates` at `square`, (candidates[square]),\n    // and propagate when values or places <= 2. Return updated candidates,\n    // unless a contradiction is detected, in which case, return false.\n    // WARNING: This modifies the contents of `candidates` directly.\n\n    // If `val` has already been eliminated from candidates[square], return early.\n    if (!this._in(val, candidates[square])) {\n      return candidates; // Already eliminated, success\n    }\n\n    // Remove `val` from candidates[square]\n    candidates[square] = candidates[square].replace(val, '');\n\n    // A. Contradiction Check 1: If the square has no candidates left after elimination.\n    const nr_candidates = candidates[square].length;\n    if (nr_candidates === 0) {\n      return false; // Contradiction: square has no possible values\n    }\n\n    // B. Propagation 1: If the square is reduced to a single candidate,\n    //    eliminate that candidate from its peers.\n    if (nr_candidates === 1) {\n      const target_val = candidates[square]; // The single remaining candidate\n      const peers = this.SQUARE_PEERS_MAP[square]; // Peers guaranteed by initialization check\n      if (!peers) return false; // Safety check\n\n      for (const peer of peers) {\n        const eliminateResult = this._eliminate(candidates, peer, target_val);\n        if (!eliminateResult) {\n          return false; // Contradiction during peer elimination\n        }\n      }\n    }\n\n    // C. Propagation 2: If a unit is reduced to only one possible place for `val`,\n    //    then assign `val` to that place.\n    const units = this.SQUARE_UNITS_MAP[square]; // Units guaranteed by initialization check\n    if (!units) return false; // Safety check\n\n    for (const unit of units) {\n      const val_places: string[] = [];\n      for (const unit_square of unit) {\n        if (this._in(val, candidates[unit_square])) {\n          val_places.push(unit_square);\n        }\n      }\n\n      // C.1 Contradiction Check 2: If there's no place left for `val` in this unit.\n      if (val_places.length === 0) {\n        return false; // Contradiction: 'val' cannot be placed in this unit\n      }\n\n      // C.2 Assignment: If there's exactly one place left for `val` in this unit.\n      if (val_places.length === 1) {\n        const target_square = val_places[0];\n        // Assign `val` to `target_square` (which involves eliminating other values)\n        // Use _assign which handles the propagation.\n        const assignResult = this._assign(candidates, target_square, val);\n        if (!assignResult) {\n          return false; // Contradiction during assignment\n        }\n      }\n    }\n\n    // If no contradictions were found during elimination and propagation, return the modified map.\n    return candidates;\n  }\n\n\n  // Square relationships\n  // -------------------------------------------------------------------------\n  // Squares, and their relationships with values, units, and peers.\n\n  private _get_square_vals_map(board: string): Record<string, string> {\n    // Ensure SQUARES is initialized\n    if (!this.SQUARES) {\n        throw new Error(\"SudokuCore not initialized. Call initialize() first.\");\n    }\n    /* Return a map of squares -> values */\n    const squares_vals_map: Record<string, string> = {};\n\n    // Make sure `board` is a string of length 81\n    if (board.length !== this.NR_SQUARES) {\n      throw new Error(\"Board/squares length mismatch.\");\n    }\n\n    for (let i = 0; i < this.SQUARES.length; ++i) {\n        squares_vals_map[this.SQUARES[i]] = board[i];\n    }\n\n    return squares_vals_map;\n  }\n\n  private _get_square_units_map(squares: string[], units: string[][]): Record<string, string[][]> {\n    /* Return a map of `squares` and their associated units (row, col, box) */\n    const square_unit_map: Record<string, string[][]> = {};\n\n    // For every square...\n    for (const cur_square of squares) {\n      // Maintain a list of the current square's units\n      const cur_square_units: string[][] = [];\n\n      // Look through the units, and see if the current square is in it,\n      // and if so, add it to the list of of the square's units.\n      for (const cur_unit of units) {\n        if (cur_unit.includes(cur_square)) { // Use includes for arrays\n          cur_square_units.push(cur_unit);\n        }\n      }\n      // Save the current square and its units to the map\n      square_unit_map[cur_square] = cur_square_units;\n    }\n\n    return square_unit_map;\n  }\n\n  private _get_square_peers_map(squares: string[], units_map: Record<string, string[][]>): Record<string, string[]> {\n    /* Return a map of `squares` and their associated peers, i.e., a set of\n    other squares in the square's unit. */\n    const square_peers_map: Record<string, string[]> = {};\n\n    // For every square...\n    for (const cur_square of squares) {\n      const cur_square_units = units_map[cur_square];\n      if (!cur_square_units) continue; // Should not happen if units_map is correct\n\n      // Maintain list of the current square's peers\n      const cur_square_peers: string[] = [];\n      const peer_set = new Set<string>(); // Use Set for efficient uniqueness check\n\n      // Look through the current square's units map...\n      for (const cur_unit of cur_square_units) {\n        for (const cur_unit_square of cur_unit) {\n          if (cur_unit_square !== cur_square) {\n            peer_set.add(cur_unit_square);\n          }\n        }\n      }\n\n      // Convert Set back to array\n      square_peers_map[cur_square] = Array.from(peer_set);\n    }\n\n    return square_peers_map;\n  }\n\n  private _get_all_units(rows: string, cols: string): string[][] {\n    /* Return a list of all units (rows, cols, boxes) */\n    const units: string[][] = [];\n\n    // Rows\n    for (const r of rows) {\n      units.push(this._cross(r, cols));\n    }\n\n    // Columns\n    for (const c of cols) {\n      units.push(this._cross(rows, c));\n    }\n\n    // Boxes\n    const row_squares = [\"ABC\", \"DEF\", \"GHI\"];\n    const col_squares = [\"123\", \"456\", \"789\"];\n    for (const rs of row_squares) {\n      for (const cs of col_squares) {\n        units.push(this._cross(rs, cs));\n      }\n    }\n\n    return units;\n  }\n\n\n  // Conversions\n  // -------------------------------------------------------------------------\n  public board_string_to_grid(board_string: string): string[][] {\n    /* Convert a board string to a two-dimensional array */\n    const rows: string[][] = [];\n    let cur_row: string[] = [];\n    for (let i = 0; i < board_string.length; i++) {\n      cur_row.push(board_string[i]);\n      if ((i % 9) === 8) {\n        rows.push(cur_row);\n        cur_row = [];\n      }\n    }\n    return rows;\n  }\n\n  public board_grid_to_string(board_grid: string[][]): string {\n    /* Convert a board grid to a string */\n    let board_string = \"\";\n    for (let r = 0; r < 9; ++r) {\n      for (let c = 0; c < 9; ++c) {\n        // Basic safety check for grid structure\n        if (board_grid[r] && board_grid[r][c] !== undefined) {\n            board_string += board_grid[r][c];\n        } else {\n            // Handle potentially malformed grid - append blank or throw error\n            console.warn(`Malformed grid at row ${r}, col ${c}. Appending blank.`);\n            board_string += this.BLANK_CHAR;\n            // Or: throw new Error(`Malformed grid at row ${r}, col ${c}`);\n        }\n      }\n    }\n    // Add length check\n    if (board_string.length !== this.NR_SQUARES) {\n        console.error(`Resulting string length ${board_string.length} does not match expected ${this.NR_SQUARES}`);\n        // Potentially throw error or return truncated/padded string\n    }\n    return board_string;\n  }\n\n\n  // Utility\n  // -------------------------------------------------------------------------\n\n  public print_board(board: string): void {\n    /* Print a sudoku `board` to the console. */\n\n    // Assure a valid board\n    const report = this.validate_board(board);\n    if (report !== true) {\n      throw new Error(report);\n    }\n\n    const V_PADDING = \" \";  // Insert after each square\n    const H_PADDING = '\\n'; // Insert after each row\n\n    const V_BOX_PADDING = \"  \"; // Box vertical padding\n    const H_BOX_PADDING = '\\n'; // Box horizontal padding\n\n    let display_string = \"\";\n\n    for (let i = 0; i < board.length; i++) {\n      const square = board[i];\n\n      // Add the square and some padding\n      display_string += square + V_PADDING;\n\n      // Vertical edge of a box (after 3rd, 6th square in a row)\n      // Indices 2, 5, 11, 14, etc. -> (i % 9) === 2 || (i % 9) === 5\n      if (i % 9 === 2 || i % 9 === 5) {\n        display_string += V_BOX_PADDING;\n      }\n\n      // End of a line (after 9th square)\n      if (i % 9 === 8) {\n        display_string += H_PADDING;\n\n        // Horizontal edge of a box (after 3rd, 6th row)\n        // Indices 26, 53 -> i === 26 || i === 53\n         if (i === 26 || i === 53) {\n            display_string += H_BOX_PADDING;\n         }\n      }\n    }\n\n    console.log(display_string);\n  }\n\n  public validate_board(board: string | undefined | null): true | string {\n    /* Return if the given `board` is valid or not. If it's valid, return\n    true. If it's not, return a string of the reason why it's not. */\n\n    // Check for empty/null/undefined board\n    if (!board) {\n      return \"Empty board\";\n    }\n\n    // Invalid board length\n    if (board.length !== this.NR_SQUARES) {\n      return \"Invalid board size. Board must be exactly \" + this.NR_SQUARES +\n        \" squares.\";\n    }\n\n    // Check for invalid characters\n    for (let i = 0; i < board.length; i++) {\n      const char = board[i];\n      if (!this._in(char, SudokuCore.DIGITS) && char !== this.BLANK_CHAR) {\n        return \"Invalid board character encountered at index \" + i +\n          \": \" + char;\n      }\n    }\n\n    // Otherwise, we're good. Return true.\n    return true;\n  }\n\n  // Helper method adjusted for string inputs as used in this class\n  private _cross(a: string, b: string): string[] {\n    /* Cross product of all elements in `a` and `b`, e.g.,\n    _cross(\"ABC\", \"123\") ->\n    [\"A1\", \"A2\", \"A3\", \"B1\", \"B2\", \"B3\", \"C1\", \"C2\", \"C3\"]\n    */\n    const result: string[] = [];\n    for (const charA of a) {\n      for (const charB of b) {\n        result.push(charA + charB);\n      }\n    }\n    return result;\n  }\n\n  private _in(v: string, seq: string): boolean;\n  private _in<T>(v: T, seq: T[]): boolean;\n  private _in(v: any, seq: string | any[]): boolean {\n    /* Return if a value `v` is in sequence `seq`. Overloaded for string and array. */\n    return seq.indexOf(v) !== -1;\n  }\n\n  // Note: first_true is not used in the provided code, but kept for completeness\n  private first_true(seq: any[]): any | false {\n    /* Return the first element in `seq` that is true. If no element is\n    true, return false.\n    */\n    for (const item of seq) {\n      if (item) {\n        return item;\n      }\n    }\n    return false;\n  }\n\n  // Using Fisher-Yates (Knuth) shuffle algorithm for better randomness and simplicity\n  private _shuffle<T>(seq: T[]): T[] {\n    /* Return a shuffled version of `seq` */\n    const shuffled = [...seq]; // Create a copy\n    for (let i = shuffled.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // Swap\n    }\n    return shuffled;\n  }\n\n  private _rand_range(max: number, min: number = 0): number {\n    /* Get a random integer in the range of `min` (inclusive) to `max` (exclusive).\n    */\n    if (max <= min) {\n        // Avoid issues with range, return min or throw error\n        // console.warn(`_rand_range called with max (${max}) <= min (${min}). Returning min.`);\n        if (max < min) throw new Error(`_rand_range: max (${max}) cannot be less than min (${min})`);\n        return min; // If max === min, the only possible value is min, but range is exclusive of max.\n                    // Throwing might be safer depending on expected usage.\n                    // Let's throw if max <= min to indicate invalid input for exclusive range.\n        // throw new Error(`_rand_range: max (${max}) must be greater than min (${min})`);\n    }\n    return Math.floor(Math.random() * (max - min)) + min;\n  }\n\n  // Using Set for efficient duplicate removal\n  private _strip_dups<T>(seq: T[]): T[] {\n    /* Strip duplicate values from `seq` */\n    return Array.from(new Set(seq));\n  }\n\n  private _force_range(nr: number | undefined | null, max: number, min: number = 0): number {\n    /* Force `nr` to be within the range from `min` (inclusive) to `max` (exclusive).\n       If `nr` is undefined/null, treat it as 0.\n    */\n    const num = (nr === undefined || nr === null) ? 0 : nr;\n\n    if (num < min) {\n      return min;\n    }\n    // The original comment implied max inclusive, but standard ranges are often exclusive.\n    // Assuming max is exclusive based on typical range functions.\n    if (num >= max) {\n      return max - 1; // Return the highest valid value within the exclusive range\n    }\n    return num;\n  }\n\n}\n// --- END OF FILE sudoku_core.ts ---"]}